CCS PCM C Compiler, Version 5.007, 61971               13-Ara-18 23:52

               Filename:   C:\Users\HAKAN TAMBUÐA\Desktop\Görüntü iþleme Dersi Projesi\Görüntü_Ders_Pic_Kodlarý\Kod10\Kod10.lst

               ROM used:   2010 words (25%)
                           Largest free fragment is 2048
               RAM used:   68 (18%) at main() level
                           71 (19%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  07
0001:  MOVWF  0A
0002:  GOTO   747
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   040
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
....................  
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #fuses XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOPUT,NOWRT,NODEBUG,NOCPD 
.................... #use delay(crystal=20000000) 
0031:  MOVLW  03
0032:  SUBWF  61,F
0033:  BTFSS  03.0
0034:  GOTO   03F
0035:  MOVLW  61
0036:  MOVWF  04
0037:  BCF    03.7
0038:  MOVF   00,W
0039:  BTFSC  03.2
003A:  GOTO   03F
003B:  GOTO   03D
003C:  GOTO   03D
003D:  DECFSZ 00,F
003E:  GOTO   03C
003F:  RETURN
*
0731:  MOVLW  5F
0732:  MOVWF  04
0733:  BCF    03.7
0734:  MOVF   00,W
0735:  BTFSC  03.2
0736:  GOTO   744
0737:  MOVLW  06
0738:  MOVWF  78
0739:  CLRF   77
073A:  DECFSZ 77,F
073B:  GOTO   73A
073C:  DECFSZ 78,F
073D:  GOTO   739
073E:  MOVLW  7B
073F:  MOVWF  77
0740:  DECFSZ 77,F
0741:  GOTO   740
0742:  DECFSZ 00,F
0743:  GOTO   737
0744:  BCF    0A.3
0745:  BCF    0A.4
0746:  GOTO   7A9 (RETURN)
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N, stop=1) 
....................                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0773:  BCF    03.5
0774:  CLRF   27
0775:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... // AÇIKLAMALAR 
.................... // Xdir pin=High ise saða döner, Zdir pin Hýgh ise yukarý döner. enable pin HIGH ise motor pasif olur. 
....................  
.................... // Deðiþken Tanýmlamalarý 
.................... #define stepX_dir pin_c4 
.................... #define stepX_step pin_d3 
.................... #define stepX_E pin_d2 
.................... #define stepZ_dir pin_c3 
.................... #define stepZ_step pin_d0 
.................... #define stepZ_E pin_d1 
.................... #define led1x1 pin_b5 
.................... #define led1x2 pin_b4 
.................... #define led1x3 pin_b3 
.................... #define led2x1 pin_b2 
.................... #define led2x2 pin_b1 
.................... #define led2x3 pin_b0 
.................... #define led3x1 pin_d7 
.................... #define led3x2 pin_d6 
.................... #define led3x3 pin_d5 
....................  
.................... char gelenVeri; 
.................... // OTOMATÝK MOD DEÐÝÞKENLER 
.................... int16 adim=30, pulseSure=1000; 
.................... // MANUEL MOD DEÐÝÞKENLER 
.................... int16 adim1=100, pulseSure1=1000, pulseSure3=400; 
.................... // EVE GÝT DEÐÝÞKENLER 
.................... signed int16 xSayac=0, zSayac=0; 
.................... int16 adimSag, adimSol, adimUst, adimAlt; 
.................... //////-----------////// 
.................... int16 i,j,k,b,a,c,d,e,f,g,h,n; 
.................... int sayma=1; 
....................  
....................  
....................  
....................  
....................  
.................... void sagust() 
.................... { 
....................      output_low(led1x1); 
*
0619:  BSF    03.5
061A:  BCF    06.5
061B:  BCF    03.5
061C:  BCF    06.5
....................      output_low(led1x2);  
061D:  BSF    03.5
061E:  BCF    06.4
061F:  BCF    03.5
0620:  BCF    06.4
....................      output_high(led1x3);  
0621:  BSF    03.5
0622:  BCF    06.3
0623:  BCF    03.5
0624:  BSF    06.3
....................      output_low(led2x1);  
0625:  BSF    03.5
0626:  BCF    06.2
0627:  BCF    03.5
0628:  BCF    06.2
....................      output_low(led2x2);  
0629:  BSF    03.5
062A:  BCF    06.1
062B:  BCF    03.5
062C:  BCF    06.1
....................      output_low(led2x3);  
062D:  BSF    03.5
062E:  BCF    06.0
062F:  BCF    03.5
0630:  BCF    06.0
....................      output_low(led3x1);  
0631:  BSF    03.5
0632:  BCF    08.7
0633:  BCF    03.5
0634:  BCF    08.7
....................      output_low(led3x2);  
0635:  BSF    03.5
0636:  BCF    08.6
0637:  BCF    03.5
0638:  BCF    08.6
....................      output_low(led3x3);  
0639:  BSF    03.5
063A:  BCF    08.5
063B:  BCF    03.5
063C:  BCF    08.5
.................... } 
.................... void ust() 
.................... { 
....................      output_low(led1x1); 
*
05F1:  BSF    03.5
05F2:  BCF    06.5
05F3:  BCF    03.5
05F4:  BCF    06.5
....................      output_high(led1x2);  
05F5:  BSF    03.5
05F6:  BCF    06.4
05F7:  BCF    03.5
05F8:  BSF    06.4
....................      output_low(led1x3);  
05F9:  BSF    03.5
05FA:  BCF    06.3
05FB:  BCF    03.5
05FC:  BCF    06.3
....................      output_low(led2x1);  
05FD:  BSF    03.5
05FE:  BCF    06.2
05FF:  BCF    03.5
0600:  BCF    06.2
....................      output_low(led2x2);  
0601:  BSF    03.5
0602:  BCF    06.1
0603:  BCF    03.5
0604:  BCF    06.1
....................      output_low(led2x3);  
0605:  BSF    03.5
0606:  BCF    06.0
0607:  BCF    03.5
0608:  BCF    06.0
....................      output_low(led3x1);  
0609:  BSF    03.5
060A:  BCF    08.7
060B:  BCF    03.5
060C:  BCF    08.7
....................      output_low(led3x2);  
060D:  BSF    03.5
060E:  BCF    08.6
060F:  BCF    03.5
0610:  BCF    08.6
....................      output_low(led3x3);  
0611:  BSF    03.5
0612:  BCF    08.5
0613:  BCF    03.5
0614:  BCF    08.5
.................... } 
.................... void solust() 
.................... { 
....................      output_high(led1x1); 
*
05C9:  BSF    03.5
05CA:  BCF    06.5
05CB:  BCF    03.5
05CC:  BSF    06.5
....................      output_low(led1x2);  
05CD:  BSF    03.5
05CE:  BCF    06.4
05CF:  BCF    03.5
05D0:  BCF    06.4
....................      output_low(led1x3);  
05D1:  BSF    03.5
05D2:  BCF    06.3
05D3:  BCF    03.5
05D4:  BCF    06.3
....................      output_low(led2x1);  
05D5:  BSF    03.5
05D6:  BCF    06.2
05D7:  BCF    03.5
05D8:  BCF    06.2
....................      output_low(led2x2);  
05D9:  BSF    03.5
05DA:  BCF    06.1
05DB:  BCF    03.5
05DC:  BCF    06.1
....................      output_low(led2x3);  
05DD:  BSF    03.5
05DE:  BCF    06.0
05DF:  BCF    03.5
05E0:  BCF    06.0
....................      output_low(led3x1);  
05E1:  BSF    03.5
05E2:  BCF    08.7
05E3:  BCF    03.5
05E4:  BCF    08.7
....................      output_low(led3x2);  
05E5:  BSF    03.5
05E6:  BCF    08.6
05E7:  BCF    03.5
05E8:  BCF    08.6
....................      output_low(led3x3);  
05E9:  BSF    03.5
05EA:  BCF    08.5
05EB:  BCF    03.5
05EC:  BCF    08.5
.................... } 
.................... void sag() 
.................... { 
....................      output_low(led1x1); 
*
0691:  BSF    03.5
0692:  BCF    06.5
0693:  BCF    03.5
0694:  BCF    06.5
....................      output_low(led1x2);  
0695:  BSF    03.5
0696:  BCF    06.4
0697:  BCF    03.5
0698:  BCF    06.4
....................      output_low(led1x3);  
0699:  BSF    03.5
069A:  BCF    06.3
069B:  BCF    03.5
069C:  BCF    06.3
....................      output_low(led2x1);  
069D:  BSF    03.5
069E:  BCF    06.2
069F:  BCF    03.5
06A0:  BCF    06.2
....................      output_low(led2x2);  
06A1:  BSF    03.5
06A2:  BCF    06.1
06A3:  BCF    03.5
06A4:  BCF    06.1
....................      output_high(led2x3);  
06A5:  BSF    03.5
06A6:  BCF    06.0
06A7:  BCF    03.5
06A8:  BSF    06.0
....................      output_low(led3x1);  
06A9:  BSF    03.5
06AA:  BCF    08.7
06AB:  BCF    03.5
06AC:  BCF    08.7
....................      output_low(led3x2);  
06AD:  BSF    03.5
06AE:  BCF    08.6
06AF:  BCF    03.5
06B0:  BCF    08.6
....................      output_low(led3x3);  
06B1:  BSF    03.5
06B2:  BCF    08.5
06B3:  BCF    03.5
06B4:  BCF    08.5
.................... } 
.................... void orta() 
.................... { 
....................      output_low(led1x1); 
*
0669:  BSF    03.5
066A:  BCF    06.5
066B:  BCF    03.5
066C:  BCF    06.5
....................      output_low(led1x2);  
066D:  BSF    03.5
066E:  BCF    06.4
066F:  BCF    03.5
0670:  BCF    06.4
....................      output_low(led1x3);  
0671:  BSF    03.5
0672:  BCF    06.3
0673:  BCF    03.5
0674:  BCF    06.3
....................      output_low(led2x1);  
0675:  BSF    03.5
0676:  BCF    06.2
0677:  BCF    03.5
0678:  BCF    06.2
....................      output_high(led2x2);  
0679:  BSF    03.5
067A:  BCF    06.1
067B:  BCF    03.5
067C:  BSF    06.1
....................      output_low(led2x3);  
067D:  BSF    03.5
067E:  BCF    06.0
067F:  BCF    03.5
0680:  BCF    06.0
....................      output_low(led3x1);  
0681:  BSF    03.5
0682:  BCF    08.7
0683:  BCF    03.5
0684:  BCF    08.7
....................      output_low(led3x2);  
0685:  BSF    03.5
0686:  BCF    08.6
0687:  BCF    03.5
0688:  BCF    08.6
....................      output_low(led3x3);  
0689:  BSF    03.5
068A:  BCF    08.5
068B:  BCF    03.5
068C:  BCF    08.5
.................... } 
.................... void sol() 
.................... { 
....................      output_low(led1x1); 
*
0641:  BSF    03.5
0642:  BCF    06.5
0643:  BCF    03.5
0644:  BCF    06.5
....................      output_low(led1x2);  
0645:  BSF    03.5
0646:  BCF    06.4
0647:  BCF    03.5
0648:  BCF    06.4
....................      output_low(led1x3);  
0649:  BSF    03.5
064A:  BCF    06.3
064B:  BCF    03.5
064C:  BCF    06.3
....................      output_high(led2x1);  
064D:  BSF    03.5
064E:  BCF    06.2
064F:  BCF    03.5
0650:  BSF    06.2
....................      output_low(led2x2);  
0651:  BSF    03.5
0652:  BCF    06.1
0653:  BCF    03.5
0654:  BCF    06.1
....................      output_low(led2x3);  
0655:  BSF    03.5
0656:  BCF    06.0
0657:  BCF    03.5
0658:  BCF    06.0
....................      output_low(led3x1);  
0659:  BSF    03.5
065A:  BCF    08.7
065B:  BCF    03.5
065C:  BCF    08.7
....................      output_low(led3x2);  
065D:  BSF    03.5
065E:  BCF    08.6
065F:  BCF    03.5
0660:  BCF    08.6
....................      output_low(led3x3);  
0661:  BSF    03.5
0662:  BCF    08.5
0663:  BCF    03.5
0664:  BCF    08.5
.................... } 
.................... void sagalt() 
.................... { 
....................      output_low(led1x1); 
*
0709:  BSF    03.5
070A:  BCF    06.5
070B:  BCF    03.5
070C:  BCF    06.5
....................      output_low(led1x2);  
070D:  BSF    03.5
070E:  BCF    06.4
070F:  BCF    03.5
0710:  BCF    06.4
....................      output_low(led1x3);  
0711:  BSF    03.5
0712:  BCF    06.3
0713:  BCF    03.5
0714:  BCF    06.3
....................      output_low(led2x1);  
0715:  BSF    03.5
0716:  BCF    06.2
0717:  BCF    03.5
0718:  BCF    06.2
....................      output_low(led2x2);  
0719:  BSF    03.5
071A:  BCF    06.1
071B:  BCF    03.5
071C:  BCF    06.1
....................      output_low(led2x3);  
071D:  BSF    03.5
071E:  BCF    06.0
071F:  BCF    03.5
0720:  BCF    06.0
....................      output_low(led3x1);  
0721:  BSF    03.5
0722:  BCF    08.7
0723:  BCF    03.5
0724:  BCF    08.7
....................      output_low(led3x2);  
0725:  BSF    03.5
0726:  BCF    08.6
0727:  BCF    03.5
0728:  BCF    08.6
....................      output_high(led3x3);  
0729:  BSF    03.5
072A:  BCF    08.5
072B:  BCF    03.5
072C:  BSF    08.5
.................... } 
.................... void alt() 
.................... { 
....................      output_low(led1x1); 
*
06E1:  BSF    03.5
06E2:  BCF    06.5
06E3:  BCF    03.5
06E4:  BCF    06.5
....................      output_low(led1x2);  
06E5:  BSF    03.5
06E6:  BCF    06.4
06E7:  BCF    03.5
06E8:  BCF    06.4
....................      output_low(led1x3);  
06E9:  BSF    03.5
06EA:  BCF    06.3
06EB:  BCF    03.5
06EC:  BCF    06.3
....................      output_low(led2x1);  
06ED:  BSF    03.5
06EE:  BCF    06.2
06EF:  BCF    03.5
06F0:  BCF    06.2
....................      output_low(led2x2);  
06F1:  BSF    03.5
06F2:  BCF    06.1
06F3:  BCF    03.5
06F4:  BCF    06.1
....................      output_low(led2x3);  
06F5:  BSF    03.5
06F6:  BCF    06.0
06F7:  BCF    03.5
06F8:  BCF    06.0
....................      output_low(led3x1);  
06F9:  BSF    03.5
06FA:  BCF    08.7
06FB:  BCF    03.5
06FC:  BCF    08.7
....................      output_high(led3x2);  
06FD:  BSF    03.5
06FE:  BCF    08.6
06FF:  BCF    03.5
0700:  BSF    08.6
....................      output_low(led3x3);  
0701:  BSF    03.5
0702:  BCF    08.5
0703:  BCF    03.5
0704:  BCF    08.5
.................... } 
.................... void solalt() 
....................  
.................... { 
....................      output_low(led1x1); 
*
06B9:  BSF    03.5
06BA:  BCF    06.5
06BB:  BCF    03.5
06BC:  BCF    06.5
....................      output_low(led1x2);  
06BD:  BSF    03.5
06BE:  BCF    06.4
06BF:  BCF    03.5
06C0:  BCF    06.4
....................      output_low(led1x3);  
06C1:  BSF    03.5
06C2:  BCF    06.3
06C3:  BCF    03.5
06C4:  BCF    06.3
....................      output_low(led2x1);  
06C5:  BSF    03.5
06C6:  BCF    06.2
06C7:  BCF    03.5
06C8:  BCF    06.2
....................      output_low(led2x2);  
06C9:  BSF    03.5
06CA:  BCF    06.1
06CB:  BCF    03.5
06CC:  BCF    06.1
....................      output_low(led2x3);  
06CD:  BSF    03.5
06CE:  BCF    06.0
06CF:  BCF    03.5
06D0:  BCF    06.0
....................      output_high(led3x1);  
06D1:  BSF    03.5
06D2:  BCF    08.7
06D3:  BCF    03.5
06D4:  BSF    08.7
....................      output_low(led3x2);  
06D5:  BSF    03.5
06D6:  BCF    08.6
06D7:  BCF    03.5
06D8:  BCF    08.6
....................      output_low(led3x3);  
06D9:  BSF    03.5
06DA:  BCF    08.5
06DB:  BCF    03.5
06DC:  BCF    08.5
.................... } 
....................  
....................  
....................  
.................... #int_rda 
.................... void serihaberlesme_kesmesi() 
.................... { 
....................    disable_interrupts(int_rda); 
*
0040:  BSF    03.5
0041:  BCF    0C.5
....................    gelenVeri = getchar(); 
0042:  BCF    03.5
0043:  BTFSS  0C.5
0044:  GOTO   043
0045:  MOVF   1A,W
0046:  MOVWF  2D
....................    sayma=1; 
0047:  MOVLW  01
0048:  MOVWF  5C
....................    
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    // -------------------- MANUEL KONTROL --------------- 
....................     
....................    // ---- YUKARI --- 
....................    if(gelenVeri=='U') 
0049:  MOVF   2D,W
004A:  SUBLW  55
004B:  BTFSS  03.2
004C:  GOTO   085
....................    { 
....................       output_high(stepZ_dir); 
004D:  BCF    5D.3
004E:  MOVF   5D,W
004F:  BSF    03.5
0050:  MOVWF  07
0051:  BCF    03.5
0052:  BSF    07.3
....................       for(a=0; a<adim1; a++) 
0053:  CLRF   4D
0054:  CLRF   4C
0055:  MOVF   4D,W
0056:  SUBWF  33,W
0057:  BTFSS  03.0
0058:  GOTO   085
0059:  BTFSS  03.2
005A:  GOTO   05F
005B:  MOVF   32,W
005C:  SUBWF  4C,W
005D:  BTFSC  03.0
005E:  GOTO   085
....................       {  output_high(stepZ_step); delay_us(pulseSure1); output_low(stepZ_step); delay_us(pulseSure1);  } 
005F:  BSF    03.5
0060:  BCF    08.0
0061:  BCF    03.5
0062:  BSF    08.0
0063:  MOVF   35,W
0064:  MOVWF  60
0065:  INCF   60,F
0066:  DECF   60,F
0067:  BTFSC  03.2
0068:  GOTO   06D
0069:  MOVLW  FF
006A:  MOVWF  61
006B:  CALL   031
006C:  GOTO   066
006D:  MOVF   34,W
006E:  MOVWF  61
006F:  CALL   031
0070:  BSF    03.5
0071:  BCF    08.0
0072:  BCF    03.5
0073:  BCF    08.0
0074:  MOVF   35,W
0075:  MOVWF  60
0076:  INCF   60,F
0077:  DECF   60,F
0078:  BTFSC  03.2
0079:  GOTO   07E
007A:  MOVLW  FF
007B:  MOVWF  61
007C:  CALL   031
007D:  GOTO   077
007E:  MOVF   34,W
007F:  MOVWF  61
0080:  CALL   031
0081:  INCF   4C,F
0082:  BTFSC  03.2
0083:  INCF   4D,F
0084:  GOTO   055
....................    } 
....................    // ---- AÞAÐI --- 
....................       if(gelenVeri=='O') 
0085:  MOVF   2D,W
0086:  SUBLW  4F
0087:  BTFSS  03.2
0088:  GOTO   0C1
....................    { 
....................       output_low(stepZ_dir); 
0089:  BCF    5D.3
008A:  MOVF   5D,W
008B:  BSF    03.5
008C:  MOVWF  07
008D:  BCF    03.5
008E:  BCF    07.3
....................       for(c=0; c<adim1; c++) 
008F:  CLRF   4F
0090:  CLRF   4E
0091:  MOVF   4F,W
0092:  SUBWF  33,W
0093:  BTFSS  03.0
0094:  GOTO   0C1
0095:  BTFSS  03.2
0096:  GOTO   09B
0097:  MOVF   32,W
0098:  SUBWF  4E,W
0099:  BTFSC  03.0
009A:  GOTO   0C1
....................       {  output_high(stepZ_step); delay_us(pulseSure1); output_low(stepZ_step); delay_us(pulseSure1);  } 
009B:  BSF    03.5
009C:  BCF    08.0
009D:  BCF    03.5
009E:  BSF    08.0
009F:  MOVF   35,W
00A0:  MOVWF  60
00A1:  INCF   60,F
00A2:  DECF   60,F
00A3:  BTFSC  03.2
00A4:  GOTO   0A9
00A5:  MOVLW  FF
00A6:  MOVWF  61
00A7:  CALL   031
00A8:  GOTO   0A2
00A9:  MOVF   34,W
00AA:  MOVWF  61
00AB:  CALL   031
00AC:  BSF    03.5
00AD:  BCF    08.0
00AE:  BCF    03.5
00AF:  BCF    08.0
00B0:  MOVF   35,W
00B1:  MOVWF  60
00B2:  INCF   60,F
00B3:  DECF   60,F
00B4:  BTFSC  03.2
00B5:  GOTO   0BA
00B6:  MOVLW  FF
00B7:  MOVWF  61
00B8:  CALL   031
00B9:  GOTO   0B3
00BA:  MOVF   34,W
00BB:  MOVWF  61
00BC:  CALL   031
00BD:  INCF   4E,F
00BE:  BTFSC  03.2
00BF:  INCF   4F,F
00C0:  GOTO   091
....................    } 
....................    // ----- SOLA ---- 
....................       if(gelenVeri=='J') 
00C1:  MOVF   2D,W
00C2:  SUBLW  4A
00C3:  BTFSS  03.2
00C4:  GOTO   0FD
....................    { 
....................       output_low(stepX_dir); 
00C5:  BCF    5D.4
00C6:  MOVF   5D,W
00C7:  BSF    03.5
00C8:  MOVWF  07
00C9:  BCF    03.5
00CA:  BCF    07.4
....................       for(d=0; d<adim1; d++) 
00CB:  CLRF   51
00CC:  CLRF   50
00CD:  MOVF   51,W
00CE:  SUBWF  33,W
00CF:  BTFSS  03.0
00D0:  GOTO   0FD
00D1:  BTFSS  03.2
00D2:  GOTO   0D7
00D3:  MOVF   32,W
00D4:  SUBWF  50,W
00D5:  BTFSC  03.0
00D6:  GOTO   0FD
....................       {  output_high(stepX_step); delay_us(pulseSure1); output_low(stepX_step); delay_us(pulseSure1);  } 
00D7:  BSF    03.5
00D8:  BCF    08.3
00D9:  BCF    03.5
00DA:  BSF    08.3
00DB:  MOVF   35,W
00DC:  MOVWF  60
00DD:  INCF   60,F
00DE:  DECF   60,F
00DF:  BTFSC  03.2
00E0:  GOTO   0E5
00E1:  MOVLW  FF
00E2:  MOVWF  61
00E3:  CALL   031
00E4:  GOTO   0DE
00E5:  MOVF   34,W
00E6:  MOVWF  61
00E7:  CALL   031
00E8:  BSF    03.5
00E9:  BCF    08.3
00EA:  BCF    03.5
00EB:  BCF    08.3
00EC:  MOVF   35,W
00ED:  MOVWF  60
00EE:  INCF   60,F
00EF:  DECF   60,F
00F0:  BTFSC  03.2
00F1:  GOTO   0F6
00F2:  MOVLW  FF
00F3:  MOVWF  61
00F4:  CALL   031
00F5:  GOTO   0EF
00F6:  MOVF   34,W
00F7:  MOVWF  61
00F8:  CALL   031
00F9:  INCF   50,F
00FA:  BTFSC  03.2
00FB:  INCF   51,F
00FC:  GOTO   0CD
....................    } 
....................    // ----- SAÐA ------ 
....................       if(gelenVeri=='W') 
00FD:  MOVF   2D,W
00FE:  SUBLW  57
00FF:  BTFSS  03.2
0100:  GOTO   139
....................    { 
....................       output_high(stepX_dir); 
0101:  BCF    5D.4
0102:  MOVF   5D,W
0103:  BSF    03.5
0104:  MOVWF  07
0105:  BCF    03.5
0106:  BSF    07.4
....................       for(e=0; e<adim1; e++) 
0107:  CLRF   53
0108:  CLRF   52
0109:  MOVF   53,W
010A:  SUBWF  33,W
010B:  BTFSS  03.0
010C:  GOTO   139
010D:  BTFSS  03.2
010E:  GOTO   113
010F:  MOVF   32,W
0110:  SUBWF  52,W
0111:  BTFSC  03.0
0112:  GOTO   139
....................       {  output_high(stepX_step); delay_us(pulseSure1); output_low(stepX_step); delay_us(pulseSure1);  } 
0113:  BSF    03.5
0114:  BCF    08.3
0115:  BCF    03.5
0116:  BSF    08.3
0117:  MOVF   35,W
0118:  MOVWF  60
0119:  INCF   60,F
011A:  DECF   60,F
011B:  BTFSC  03.2
011C:  GOTO   121
011D:  MOVLW  FF
011E:  MOVWF  61
011F:  CALL   031
0120:  GOTO   11A
0121:  MOVF   34,W
0122:  MOVWF  61
0123:  CALL   031
0124:  BSF    03.5
0125:  BCF    08.3
0126:  BCF    03.5
0127:  BCF    08.3
0128:  MOVF   35,W
0129:  MOVWF  60
012A:  INCF   60,F
012B:  DECF   60,F
012C:  BTFSC  03.2
012D:  GOTO   132
012E:  MOVLW  FF
012F:  MOVWF  61
0130:  CALL   031
0131:  GOTO   12B
0132:  MOVF   34,W
0133:  MOVWF  61
0134:  CALL   031
0135:  INCF   52,F
0136:  BTFSC  03.2
0137:  INCF   53,F
0138:  GOTO   109
....................    } 
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................    ////////////////////////////////////////////////////// 
....................     
....................     // --------------------- SAG USTE GÝT -------------------- 
....................    if(gelenVeri=='C')  
0139:  MOVF   2D,W
013A:  SUBLW  43
013B:  BTFSS  03.2
013C:  GOTO   1B9
....................    {   
....................       xSayac=xSayac+adim; 
013D:  MOVF   2E,W
013E:  ADDWF  38,F
013F:  MOVF   2F,W
0140:  BTFSC  03.0
0141:  INCFSZ 2F,W
0142:  ADDWF  39,F
....................       zSayac=zSayac+adim; 
0143:  MOVF   2E,W
0144:  ADDWF  3A,F
0145:  MOVF   2F,W
0146:  BTFSC  03.0
0147:  INCFSZ 2F,W
0148:  ADDWF  3B,F
....................       output_high(stepZ_dir); 
0149:  BCF    5D.3
014A:  MOVF   5D,W
014B:  BSF    03.5
014C:  MOVWF  07
014D:  BCF    03.5
014E:  BSF    07.3
....................       for(k=0; k<adim; k++) 
014F:  CLRF   49
0150:  CLRF   48
0151:  MOVF   49,W
0152:  SUBWF  2F,W
0153:  BTFSS  03.0
0154:  GOTO   181
0155:  BTFSS  03.2
0156:  GOTO   15B
0157:  MOVF   2E,W
0158:  SUBWF  48,W
0159:  BTFSC  03.0
015A:  GOTO   181
....................       {  output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure);  } 
015B:  BSF    03.5
015C:  BCF    08.0
015D:  BCF    03.5
015E:  BSF    08.0
015F:  MOVF   31,W
0160:  MOVWF  60
0161:  INCF   60,F
0162:  DECF   60,F
0163:  BTFSC  03.2
0164:  GOTO   169
0165:  MOVLW  FF
0166:  MOVWF  61
0167:  CALL   031
0168:  GOTO   162
0169:  MOVF   30,W
016A:  MOVWF  61
016B:  CALL   031
016C:  BSF    03.5
016D:  BCF    08.0
016E:  BCF    03.5
016F:  BCF    08.0
0170:  MOVF   31,W
0171:  MOVWF  60
0172:  INCF   60,F
0173:  DECF   60,F
0174:  BTFSC  03.2
0175:  GOTO   17A
0176:  MOVLW  FF
0177:  MOVWF  61
0178:  CALL   031
0179:  GOTO   173
017A:  MOVF   30,W
017B:  MOVWF  61
017C:  CALL   031
017D:  INCF   48,F
017E:  BTFSC  03.2
017F:  INCF   49,F
0180:  GOTO   151
....................       output_high(stepX_dir); 
0181:  BCF    5D.4
0182:  MOVF   5D,W
0183:  BSF    03.5
0184:  MOVWF  07
0185:  BCF    03.5
0186:  BSF    07.4
....................       for(i=0; i<adim; i++) 
0187:  CLRF   45
0188:  CLRF   44
0189:  MOVF   45,W
018A:  SUBWF  2F,W
018B:  BTFSS  03.0
018C:  GOTO   1B9
018D:  BTFSS  03.2
018E:  GOTO   193
018F:  MOVF   2E,W
0190:  SUBWF  44,W
0191:  BTFSC  03.0
0192:  GOTO   1B9
....................       {  output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure);  } 
0193:  BSF    03.5
0194:  BCF    08.3
0195:  BCF    03.5
0196:  BSF    08.3
0197:  MOVF   31,W
0198:  MOVWF  60
0199:  INCF   60,F
019A:  DECF   60,F
019B:  BTFSC  03.2
019C:  GOTO   1A1
019D:  MOVLW  FF
019E:  MOVWF  61
019F:  CALL   031
01A0:  GOTO   19A
01A1:  MOVF   30,W
01A2:  MOVWF  61
01A3:  CALL   031
01A4:  BSF    03.5
01A5:  BCF    08.3
01A6:  BCF    03.5
01A7:  BCF    08.3
01A8:  MOVF   31,W
01A9:  MOVWF  60
01AA:  INCF   60,F
01AB:  DECF   60,F
01AC:  BTFSC  03.2
01AD:  GOTO   1B2
01AE:  MOVLW  FF
01AF:  MOVWF  61
01B0:  CALL   031
01B1:  GOTO   1AB
01B2:  MOVF   30,W
01B3:  MOVWF  61
01B4:  CALL   031
01B5:  INCF   44,F
01B6:  BTFSC  03.2
01B7:  INCF   45,F
01B8:  GOTO   189
....................    }    
....................          
....................    // --------------------- YUKARI  GÝT -------------------- 
....................    if(gelenVeri=='B')  
01B9:  MOVF   2D,W
01BA:  SUBLW  42
01BB:  BTFSS  03.2
01BC:  GOTO   1FB
....................    {  
....................       zSayac=zSayac+adim; 
01BD:  MOVF   2E,W
01BE:  ADDWF  3A,F
01BF:  MOVF   2F,W
01C0:  BTFSC  03.0
01C1:  INCFSZ 2F,W
01C2:  ADDWF  3B,F
....................       output_high(stepZ_dir); 
01C3:  BCF    5D.3
01C4:  MOVF   5D,W
01C5:  BSF    03.5
01C6:  MOVWF  07
01C7:  BCF    03.5
01C8:  BSF    07.3
....................       for(k=0; k<adim; k++) 
01C9:  CLRF   49
01CA:  CLRF   48
01CB:  MOVF   49,W
01CC:  SUBWF  2F,W
01CD:  BTFSS  03.0
01CE:  GOTO   1FB
01CF:  BTFSS  03.2
01D0:  GOTO   1D5
01D1:  MOVF   2E,W
01D2:  SUBWF  48,W
01D3:  BTFSC  03.0
01D4:  GOTO   1FB
....................       { output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure);   } 
01D5:  BSF    03.5
01D6:  BCF    08.0
01D7:  BCF    03.5
01D8:  BSF    08.0
01D9:  MOVF   31,W
01DA:  MOVWF  60
01DB:  INCF   60,F
01DC:  DECF   60,F
01DD:  BTFSC  03.2
01DE:  GOTO   1E3
01DF:  MOVLW  FF
01E0:  MOVWF  61
01E1:  CALL   031
01E2:  GOTO   1DC
01E3:  MOVF   30,W
01E4:  MOVWF  61
01E5:  CALL   031
01E6:  BSF    03.5
01E7:  BCF    08.0
01E8:  BCF    03.5
01E9:  BCF    08.0
01EA:  MOVF   31,W
01EB:  MOVWF  60
01EC:  INCF   60,F
01ED:  DECF   60,F
01EE:  BTFSC  03.2
01EF:  GOTO   1F4
01F0:  MOVLW  FF
01F1:  MOVWF  61
01F2:  CALL   031
01F3:  GOTO   1ED
01F4:  MOVF   30,W
01F5:  MOVWF  61
01F6:  CALL   031
01F7:  INCF   48,F
01F8:  BTFSC  03.2
01F9:  INCF   49,F
01FA:  GOTO   1CB
....................     } 
....................        
....................    // --------------------- SOL USTE GÝT -------------------- 
....................    if(gelenVeri=='A')  
01FB:  MOVF   2D,W
01FC:  SUBLW  41
01FD:  BTFSS  03.2
01FE:  GOTO   27B
....................    {   
....................       xSayac=xSayac-adim; 
01FF:  MOVF   2E,W
0200:  SUBWF  38,F
0201:  MOVF   2F,W
0202:  BTFSS  03.0
0203:  INCFSZ 2F,W
0204:  SUBWF  39,F
....................       zSayac=zSayac+adim; 
0205:  MOVF   2E,W
0206:  ADDWF  3A,F
0207:  MOVF   2F,W
0208:  BTFSC  03.0
0209:  INCFSZ 2F,W
020A:  ADDWF  3B,F
....................       output_high(stepZ_dir); 
020B:  BCF    5D.3
020C:  MOVF   5D,W
020D:  BSF    03.5
020E:  MOVWF  07
020F:  BCF    03.5
0210:  BSF    07.3
....................       for(k=0; k<adim; k++) 
0211:  CLRF   49
0212:  CLRF   48
0213:  MOVF   49,W
0214:  SUBWF  2F,W
0215:  BTFSS  03.0
0216:  GOTO   243
0217:  BTFSS  03.2
0218:  GOTO   21D
0219:  MOVF   2E,W
021A:  SUBWF  48,W
021B:  BTFSC  03.0
021C:  GOTO   243
....................       { output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure);  } 
021D:  BSF    03.5
021E:  BCF    08.0
021F:  BCF    03.5
0220:  BSF    08.0
0221:  MOVF   31,W
0222:  MOVWF  60
0223:  INCF   60,F
0224:  DECF   60,F
0225:  BTFSC  03.2
0226:  GOTO   22B
0227:  MOVLW  FF
0228:  MOVWF  61
0229:  CALL   031
022A:  GOTO   224
022B:  MOVF   30,W
022C:  MOVWF  61
022D:  CALL   031
022E:  BSF    03.5
022F:  BCF    08.0
0230:  BCF    03.5
0231:  BCF    08.0
0232:  MOVF   31,W
0233:  MOVWF  60
0234:  INCF   60,F
0235:  DECF   60,F
0236:  BTFSC  03.2
0237:  GOTO   23C
0238:  MOVLW  FF
0239:  MOVWF  61
023A:  CALL   031
023B:  GOTO   235
023C:  MOVF   30,W
023D:  MOVWF  61
023E:  CALL   031
023F:  INCF   48,F
0240:  BTFSC  03.2
0241:  INCF   49,F
0242:  GOTO   213
....................        output_low(stepX_dir); 
0243:  BCF    5D.4
0244:  MOVF   5D,W
0245:  BSF    03.5
0246:  MOVWF  07
0247:  BCF    03.5
0248:  BCF    07.4
....................       for(j=0; j<adim; j++) 
0249:  CLRF   47
024A:  CLRF   46
024B:  MOVF   47,W
024C:  SUBWF  2F,W
024D:  BTFSS  03.0
024E:  GOTO   27B
024F:  BTFSS  03.2
0250:  GOTO   255
0251:  MOVF   2E,W
0252:  SUBWF  46,W
0253:  BTFSC  03.0
0254:  GOTO   27B
....................       { output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure);  }    
0255:  BSF    03.5
0256:  BCF    08.3
0257:  BCF    03.5
0258:  BSF    08.3
0259:  MOVF   31,W
025A:  MOVWF  60
025B:  INCF   60,F
025C:  DECF   60,F
025D:  BTFSC  03.2
025E:  GOTO   263
025F:  MOVLW  FF
0260:  MOVWF  61
0261:  CALL   031
0262:  GOTO   25C
0263:  MOVF   30,W
0264:  MOVWF  61
0265:  CALL   031
0266:  BSF    03.5
0267:  BCF    08.3
0268:  BCF    03.5
0269:  BCF    08.3
026A:  MOVF   31,W
026B:  MOVWF  60
026C:  INCF   60,F
026D:  DECF   60,F
026E:  BTFSC  03.2
026F:  GOTO   274
0270:  MOVLW  FF
0271:  MOVWF  61
0272:  CALL   031
0273:  GOTO   26D
0274:  MOVF   30,W
0275:  MOVWF  61
0276:  CALL   031
0277:  INCF   46,F
0278:  BTFSC  03.2
0279:  INCF   47,F
027A:  GOTO   24B
....................    } 
....................    // --------------------- SAGA GÝT -------------------- 
....................    if(gelenVeri=='F')  
027B:  MOVF   2D,W
027C:  SUBLW  46
027D:  BTFSS  03.2
027E:  GOTO   2BD
....................    {  
....................       xSayac=xSayac+adim; 
027F:  MOVF   2E,W
0280:  ADDWF  38,F
0281:  MOVF   2F,W
0282:  BTFSC  03.0
0283:  INCFSZ 2F,W
0284:  ADDWF  39,F
....................       output_high(stepX_dir); 
0285:  BCF    5D.4
0286:  MOVF   5D,W
0287:  BSF    03.5
0288:  MOVWF  07
0289:  BCF    03.5
028A:  BSF    07.4
....................       for(i=0; i<adim; i++) 
028B:  CLRF   45
028C:  CLRF   44
028D:  MOVF   45,W
028E:  SUBWF  2F,W
028F:  BTFSS  03.0
0290:  GOTO   2BD
0291:  BTFSS  03.2
0292:  GOTO   297
0293:  MOVF   2E,W
0294:  SUBWF  44,W
0295:  BTFSC  03.0
0296:  GOTO   2BD
....................       { output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure); } 
0297:  BSF    03.5
0298:  BCF    08.3
0299:  BCF    03.5
029A:  BSF    08.3
029B:  MOVF   31,W
029C:  MOVWF  60
029D:  INCF   60,F
029E:  DECF   60,F
029F:  BTFSC  03.2
02A0:  GOTO   2A5
02A1:  MOVLW  FF
02A2:  MOVWF  61
02A3:  CALL   031
02A4:  GOTO   29E
02A5:  MOVF   30,W
02A6:  MOVWF  61
02A7:  CALL   031
02A8:  BSF    03.5
02A9:  BCF    08.3
02AA:  BCF    03.5
02AB:  BCF    08.3
02AC:  MOVF   31,W
02AD:  MOVWF  60
02AE:  INCF   60,F
02AF:  DECF   60,F
02B0:  BTFSC  03.2
02B1:  GOTO   2B6
02B2:  MOVLW  FF
02B3:  MOVWF  61
02B4:  CALL   031
02B5:  GOTO   2AF
02B6:  MOVF   30,W
02B7:  MOVWF  61
02B8:  CALL   031
02B9:  INCF   44,F
02BA:  BTFSC  03.2
02BB:  INCF   45,F
02BC:  GOTO   28D
....................    } 
....................        
....................    // --------------------- BEKLE -------------------- 
....................    if(gelenVeri=='E')  
02BD:  MOVF   2D,W
02BE:  SUBLW  45
02BF:  BTFSS  03.2
....................    {   
....................      // BEKLE................ 
....................  
....................    } 
....................    // --------------------- SOLA GÝT -------------------- 
....................    if(gelenVeri=='D')  
02C0:  MOVF   2D,W
02C1:  SUBLW  44
02C2:  BTFSS  03.2
02C3:  GOTO   302
....................    {  
....................       xSayac=xSayac-adim; 
02C4:  MOVF   2E,W
02C5:  SUBWF  38,F
02C6:  MOVF   2F,W
02C7:  BTFSS  03.0
02C8:  INCFSZ 2F,W
02C9:  SUBWF  39,F
....................       output_low(stepX_dir); 
02CA:  BCF    5D.4
02CB:  MOVF   5D,W
02CC:  BSF    03.5
02CD:  MOVWF  07
02CE:  BCF    03.5
02CF:  BCF    07.4
....................       for(j=0; j<adim; j++) 
02D0:  CLRF   47
02D1:  CLRF   46
02D2:  MOVF   47,W
02D3:  SUBWF  2F,W
02D4:  BTFSS  03.0
02D5:  GOTO   302
02D6:  BTFSS  03.2
02D7:  GOTO   2DC
02D8:  MOVF   2E,W
02D9:  SUBWF  46,W
02DA:  BTFSC  03.0
02DB:  GOTO   302
....................       {  output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure); }  
02DC:  BSF    03.5
02DD:  BCF    08.3
02DE:  BCF    03.5
02DF:  BSF    08.3
02E0:  MOVF   31,W
02E1:  MOVWF  60
02E2:  INCF   60,F
02E3:  DECF   60,F
02E4:  BTFSC  03.2
02E5:  GOTO   2EA
02E6:  MOVLW  FF
02E7:  MOVWF  61
02E8:  CALL   031
02E9:  GOTO   2E3
02EA:  MOVF   30,W
02EB:  MOVWF  61
02EC:  CALL   031
02ED:  BSF    03.5
02EE:  BCF    08.3
02EF:  BCF    03.5
02F0:  BCF    08.3
02F1:  MOVF   31,W
02F2:  MOVWF  60
02F3:  INCF   60,F
02F4:  DECF   60,F
02F5:  BTFSC  03.2
02F6:  GOTO   2FB
02F7:  MOVLW  FF
02F8:  MOVWF  61
02F9:  CALL   031
02FA:  GOTO   2F4
02FB:  MOVF   30,W
02FC:  MOVWF  61
02FD:  CALL   031
02FE:  INCF   46,F
02FF:  BTFSC  03.2
0300:  INCF   47,F
0301:  GOTO   2D2
....................    } 
....................    // --------------------- SAG ALTA GÝT -------------------- 
....................    if(gelenVeri=='K')  
0302:  MOVF   2D,W
0303:  SUBLW  4B
0304:  BTFSS  03.2
0305:  GOTO   382
....................    {   
....................       xSayac=xSayac+adim; 
0306:  MOVF   2E,W
0307:  ADDWF  38,F
0308:  MOVF   2F,W
0309:  BTFSC  03.0
030A:  INCFSZ 2F,W
030B:  ADDWF  39,F
....................       zSayac=zSayac-adim; 
030C:  MOVF   2E,W
030D:  SUBWF  3A,F
030E:  MOVF   2F,W
030F:  BTFSS  03.0
0310:  INCFSZ 2F,W
0311:  SUBWF  3B,F
....................       output_low(stepZ_dir); 
0312:  BCF    5D.3
0313:  MOVF   5D,W
0314:  BSF    03.5
0315:  MOVWF  07
0316:  BCF    03.5
0317:  BCF    07.3
....................       for(b=0; b<adim; b++) 
0318:  CLRF   4B
0319:  CLRF   4A
031A:  MOVF   4B,W
031B:  SUBWF  2F,W
031C:  BTFSS  03.0
031D:  GOTO   34A
031E:  BTFSS  03.2
031F:  GOTO   324
0320:  MOVF   2E,W
0321:  SUBWF  4A,W
0322:  BTFSC  03.0
0323:  GOTO   34A
....................       { output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure); }    
0324:  BSF    03.5
0325:  BCF    08.0
0326:  BCF    03.5
0327:  BSF    08.0
0328:  MOVF   31,W
0329:  MOVWF  60
032A:  INCF   60,F
032B:  DECF   60,F
032C:  BTFSC  03.2
032D:  GOTO   332
032E:  MOVLW  FF
032F:  MOVWF  61
0330:  CALL   031
0331:  GOTO   32B
0332:  MOVF   30,W
0333:  MOVWF  61
0334:  CALL   031
0335:  BSF    03.5
0336:  BCF    08.0
0337:  BCF    03.5
0338:  BCF    08.0
0339:  MOVF   31,W
033A:  MOVWF  60
033B:  INCF   60,F
033C:  DECF   60,F
033D:  BTFSC  03.2
033E:  GOTO   343
033F:  MOVLW  FF
0340:  MOVWF  61
0341:  CALL   031
0342:  GOTO   33C
0343:  MOVF   30,W
0344:  MOVWF  61
0345:  CALL   031
0346:  INCF   4A,F
0347:  BTFSC  03.2
0348:  INCF   4B,F
0349:  GOTO   31A
....................        output_high(stepX_dir); 
034A:  BCF    5D.4
034B:  MOVF   5D,W
034C:  BSF    03.5
034D:  MOVWF  07
034E:  BCF    03.5
034F:  BSF    07.4
....................       for(i=0; i<adim; i++) 
0350:  CLRF   45
0351:  CLRF   44
0352:  MOVF   45,W
0353:  SUBWF  2F,W
0354:  BTFSS  03.0
0355:  GOTO   382
0356:  BTFSS  03.2
0357:  GOTO   35C
0358:  MOVF   2E,W
0359:  SUBWF  44,W
035A:  BTFSC  03.0
035B:  GOTO   382
....................       {   output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure); }     
035C:  BSF    03.5
035D:  BCF    08.3
035E:  BCF    03.5
035F:  BSF    08.3
0360:  MOVF   31,W
0361:  MOVWF  60
0362:  INCF   60,F
0363:  DECF   60,F
0364:  BTFSC  03.2
0365:  GOTO   36A
0366:  MOVLW  FF
0367:  MOVWF  61
0368:  CALL   031
0369:  GOTO   363
036A:  MOVF   30,W
036B:  MOVWF  61
036C:  CALL   031
036D:  BSF    03.5
036E:  BCF    08.3
036F:  BCF    03.5
0370:  BCF    08.3
0371:  MOVF   31,W
0372:  MOVWF  60
0373:  INCF   60,F
0374:  DECF   60,F
0375:  BTFSC  03.2
0376:  GOTO   37B
0377:  MOVLW  FF
0378:  MOVWF  61
0379:  CALL   031
037A:  GOTO   374
037B:  MOVF   30,W
037C:  MOVWF  61
037D:  CALL   031
037E:  INCF   44,F
037F:  BTFSC  03.2
0380:  INCF   45,F
0381:  GOTO   352
....................    } 
....................    // --------------------- ALTA GÝT -------------------- 
....................    if(gelenVeri=='H')  
0382:  MOVF   2D,W
0383:  SUBLW  48
0384:  BTFSS  03.2
0385:  GOTO   3C4
....................    {   
....................       zSayac=zSayac-adim; 
0386:  MOVF   2E,W
0387:  SUBWF  3A,F
0388:  MOVF   2F,W
0389:  BTFSS  03.0
038A:  INCFSZ 2F,W
038B:  SUBWF  3B,F
....................       output_low(stepZ_dir); 
038C:  BCF    5D.3
038D:  MOVF   5D,W
038E:  BSF    03.5
038F:  MOVWF  07
0390:  BCF    03.5
0391:  BCF    07.3
....................       for(k=0; k<adim; k++) 
0392:  CLRF   49
0393:  CLRF   48
0394:  MOVF   49,W
0395:  SUBWF  2F,W
0396:  BTFSS  03.0
0397:  GOTO   3C4
0398:  BTFSS  03.2
0399:  GOTO   39E
039A:  MOVF   2E,W
039B:  SUBWF  48,W
039C:  BTFSC  03.0
039D:  GOTO   3C4
....................       { output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure);  } 
039E:  BSF    03.5
039F:  BCF    08.0
03A0:  BCF    03.5
03A1:  BSF    08.0
03A2:  MOVF   31,W
03A3:  MOVWF  60
03A4:  INCF   60,F
03A5:  DECF   60,F
03A6:  BTFSC  03.2
03A7:  GOTO   3AC
03A8:  MOVLW  FF
03A9:  MOVWF  61
03AA:  CALL   031
03AB:  GOTO   3A5
03AC:  MOVF   30,W
03AD:  MOVWF  61
03AE:  CALL   031
03AF:  BSF    03.5
03B0:  BCF    08.0
03B1:  BCF    03.5
03B2:  BCF    08.0
03B3:  MOVF   31,W
03B4:  MOVWF  60
03B5:  INCF   60,F
03B6:  DECF   60,F
03B7:  BTFSC  03.2
03B8:  GOTO   3BD
03B9:  MOVLW  FF
03BA:  MOVWF  61
03BB:  CALL   031
03BC:  GOTO   3B6
03BD:  MOVF   30,W
03BE:  MOVWF  61
03BF:  CALL   031
03C0:  INCF   48,F
03C1:  BTFSC  03.2
03C2:  INCF   49,F
03C3:  GOTO   394
....................  
....................    } 
....................    // --------------------- SOL ALTA GÝT -------------------- 
....................    if(gelenVeri=='G')  
03C4:  MOVF   2D,W
03C5:  SUBLW  47
03C6:  BTFSS  03.2
03C7:  GOTO   444
....................    {   
....................       zSayac=zSayac-adim; 
03C8:  MOVF   2E,W
03C9:  SUBWF  3A,F
03CA:  MOVF   2F,W
03CB:  BTFSS  03.0
03CC:  INCFSZ 2F,W
03CD:  SUBWF  3B,F
....................       xSayac=xSayac-adim; 
03CE:  MOVF   2E,W
03CF:  SUBWF  38,F
03D0:  MOVF   2F,W
03D1:  BTFSS  03.0
03D2:  INCFSZ 2F,W
03D3:  SUBWF  39,F
....................       output_low(stepZ_dir); 
03D4:  BCF    5D.3
03D5:  MOVF   5D,W
03D6:  BSF    03.5
03D7:  MOVWF  07
03D8:  BCF    03.5
03D9:  BCF    07.3
....................       for(b=0; b<adim; b++) 
03DA:  CLRF   4B
03DB:  CLRF   4A
03DC:  MOVF   4B,W
03DD:  SUBWF  2F,W
03DE:  BTFSS  03.0
03DF:  GOTO   40C
03E0:  BTFSS  03.2
03E1:  GOTO   3E6
03E2:  MOVF   2E,W
03E3:  SUBWF  4A,W
03E4:  BTFSC  03.0
03E5:  GOTO   40C
....................       {  output_high(stepZ_step); delay_us(pulseSure); output_low(stepZ_step); delay_us(pulseSure); } 
03E6:  BSF    03.5
03E7:  BCF    08.0
03E8:  BCF    03.5
03E9:  BSF    08.0
03EA:  MOVF   31,W
03EB:  MOVWF  60
03EC:  INCF   60,F
03ED:  DECF   60,F
03EE:  BTFSC  03.2
03EF:  GOTO   3F4
03F0:  MOVLW  FF
03F1:  MOVWF  61
03F2:  CALL   031
03F3:  GOTO   3ED
03F4:  MOVF   30,W
03F5:  MOVWF  61
03F6:  CALL   031
03F7:  BSF    03.5
03F8:  BCF    08.0
03F9:  BCF    03.5
03FA:  BCF    08.0
03FB:  MOVF   31,W
03FC:  MOVWF  60
03FD:  INCF   60,F
03FE:  DECF   60,F
03FF:  BTFSC  03.2
0400:  GOTO   405
0401:  MOVLW  FF
0402:  MOVWF  61
0403:  CALL   031
0404:  GOTO   3FE
0405:  MOVF   30,W
0406:  MOVWF  61
0407:  CALL   031
0408:  INCF   4A,F
0409:  BTFSC  03.2
040A:  INCF   4B,F
040B:  GOTO   3DC
....................       output_low(stepX_dir); 
040C:  BCF    5D.4
040D:  MOVF   5D,W
040E:  BSF    03.5
040F:  MOVWF  07
0410:  BCF    03.5
0411:  BCF    07.4
....................       for(j=0; j<adim; j++) 
0412:  CLRF   47
0413:  CLRF   46
0414:  MOVF   47,W
0415:  SUBWF  2F,W
0416:  BTFSS  03.0
0417:  GOTO   444
0418:  BTFSS  03.2
0419:  GOTO   41E
041A:  MOVF   2E,W
041B:  SUBWF  46,W
041C:  BTFSC  03.0
041D:  GOTO   444
....................       { output_high(stepX_step); delay_us(pulseSure); output_low(stepX_step); delay_us(pulseSure);  } 
041E:  BSF    03.5
041F:  BCF    08.3
0420:  BCF    03.5
0421:  BSF    08.3
0422:  MOVF   31,W
0423:  MOVWF  60
0424:  INCF   60,F
0425:  DECF   60,F
0426:  BTFSC  03.2
0427:  GOTO   42C
0428:  MOVLW  FF
0429:  MOVWF  61
042A:  CALL   031
042B:  GOTO   425
042C:  MOVF   30,W
042D:  MOVWF  61
042E:  CALL   031
042F:  BSF    03.5
0430:  BCF    08.3
0431:  BCF    03.5
0432:  BCF    08.3
0433:  MOVF   31,W
0434:  MOVWF  60
0435:  INCF   60,F
0436:  DECF   60,F
0437:  BTFSC  03.2
0438:  GOTO   43D
0439:  MOVLW  FF
043A:  MOVWF  61
043B:  CALL   031
043C:  GOTO   436
043D:  MOVF   30,W
043E:  MOVWF  61
043F:  CALL   031
0440:  INCF   46,F
0441:  BTFSC  03.2
0442:  INCF   47,F
0443:  GOTO   414
....................    } 
....................             
....................     // ------------------------ EVE GÝT --------------------------------- 
....................     if(gelenVeri=='I'&& sayma==1) 
0444:  MOVF   2D,W
0445:  SUBLW  49
0446:  BTFSS  03.2
0447:  GOTO   5C5
0448:  DECFSZ 5C,W
0449:  GOTO   5C5
....................     { 
....................     // X sayac eksi deðer ise saga dogru gitsin 
....................      if(abs(xSayac)!=xSayac) 
044A:  MOVF   39,W
044B:  MOVWF  7A
044C:  MOVF   38,W
044D:  BTFSS  39.7
044E:  GOTO   458
044F:  MOVF   38,W
0450:  SUBLW  00
0451:  MOVWF  77
0452:  CLRF   7A
0453:  MOVF   39,W
0454:  BTFSS  03.0
0455:  INCFSZ 39,W
0456:  SUBWF  7A,F
0457:  MOVF   77,W
0458:  MOVWF  60
0459:  MOVF   7A,W
045A:  MOVWF  61
045B:  MOVF   38,W
045C:  SUBWF  60,W
045D:  BTFSS  03.2
045E:  GOTO   463
045F:  MOVF   39,W
0460:  SUBWF  61,W
0461:  BTFSC  03.2
0462:  GOTO   4AC
....................      {    
....................          adimSag=abs(xSayac); 
0463:  MOVF   39,W
0464:  MOVWF  7A
0465:  MOVF   38,W
0466:  BTFSS  39.7
0467:  GOTO   471
0468:  MOVF   38,W
0469:  SUBLW  00
046A:  MOVWF  77
046B:  CLRF   7A
046C:  MOVF   39,W
046D:  BTFSS  03.0
046E:  INCFSZ 39,W
046F:  SUBWF  7A,F
0470:  MOVF   77,W
0471:  MOVWF  3C
0472:  MOVF   7A,W
0473:  MOVWF  3D
....................          output_high(stepX_dir); 
0474:  BCF    5D.4
0475:  MOVF   5D,W
0476:  BSF    03.5
0477:  MOVWF  07
0478:  BCF    03.5
0479:  BSF    07.4
....................        for(n=0; n<adimSag; n++) 
047A:  CLRF   5B
047B:  CLRF   5A
047C:  MOVF   5B,W
047D:  SUBWF  3D,W
047E:  BTFSS  03.0
047F:  GOTO   4AC
0480:  BTFSS  03.2
0481:  GOTO   486
0482:  MOVF   3C,W
0483:  SUBWF  5A,W
0484:  BTFSC  03.0
0485:  GOTO   4AC
....................         {  output_high(stepX_step); delay_us(pulseSure3); output_low(stepX_step); delay_us(pulseSure3);  } 
0486:  BSF    03.5
0487:  BCF    08.3
0488:  BCF    03.5
0489:  BSF    08.3
048A:  MOVF   37,W
048B:  MOVWF  60
048C:  INCF   60,F
048D:  DECF   60,F
048E:  BTFSC  03.2
048F:  GOTO   494
0490:  MOVLW  FF
0491:  MOVWF  61
0492:  CALL   031
0493:  GOTO   48D
0494:  MOVF   36,W
0495:  MOVWF  61
0496:  CALL   031
0497:  BSF    03.5
0498:  BCF    08.3
0499:  BCF    03.5
049A:  BCF    08.3
049B:  MOVF   37,W
049C:  MOVWF  60
049D:  INCF   60,F
049E:  DECF   60,F
049F:  BTFSC  03.2
04A0:  GOTO   4A5
04A1:  MOVLW  FF
04A2:  MOVWF  61
04A3:  CALL   031
04A4:  GOTO   49E
04A5:  MOVF   36,W
04A6:  MOVWF  61
04A7:  CALL   031
04A8:  INCF   5A,F
04A9:  BTFSC  03.2
04AA:  INCF   5B,F
04AB:  GOTO   47C
....................          
....................      
....................     } 
....................      // Z sayac eksi deðer ise yukarý cýksýn 
....................      if(abs(zSayac)!=zSayac) 
04AC:  MOVF   3B,W
04AD:  MOVWF  7A
04AE:  MOVF   3A,W
04AF:  BTFSS  3B.7
04B0:  GOTO   4BA
04B1:  MOVF   3A,W
04B2:  SUBLW  00
04B3:  MOVWF  77
04B4:  CLRF   7A
04B5:  MOVF   3B,W
04B6:  BTFSS  03.0
04B7:  INCFSZ 3B,W
04B8:  SUBWF  7A,F
04B9:  MOVF   77,W
04BA:  MOVWF  60
04BB:  MOVF   7A,W
04BC:  MOVWF  61
04BD:  MOVF   3A,W
04BE:  SUBWF  60,W
04BF:  BTFSS  03.2
04C0:  GOTO   4C5
04C1:  MOVF   3B,W
04C2:  SUBWF  61,W
04C3:  BTFSC  03.2
04C4:  GOTO   50E
....................      {  
....................      adimUst=abs(zSayac); 
04C5:  MOVF   3B,W
04C6:  MOVWF  7A
04C7:  MOVF   3A,W
04C8:  BTFSS  3B.7
04C9:  GOTO   4D3
04CA:  MOVF   3A,W
04CB:  SUBLW  00
04CC:  MOVWF  77
04CD:  CLRF   7A
04CE:  MOVF   3B,W
04CF:  BTFSS  03.0
04D0:  INCFSZ 3B,W
04D1:  SUBWF  7A,F
04D2:  MOVF   77,W
04D3:  MOVWF  40
04D4:  MOVF   7A,W
04D5:  MOVWF  41
....................         output_high(stepZ_dir); 
04D6:  BCF    5D.3
04D7:  MOVF   5D,W
04D8:  BSF    03.5
04D9:  MOVWF  07
04DA:  BCF    03.5
04DB:  BSF    07.3
....................    for(f=0; f<adimUst; f++) 
04DC:  CLRF   55
04DD:  CLRF   54
04DE:  MOVF   55,W
04DF:  SUBWF  41,W
04E0:  BTFSS  03.0
04E1:  GOTO   50E
04E2:  BTFSS  03.2
04E3:  GOTO   4E8
04E4:  MOVF   40,W
04E5:  SUBWF  54,W
04E6:  BTFSC  03.0
04E7:  GOTO   50E
....................    {  output_high(stepZ_step); delay_us(pulseSure3); output_low(stepZ_step); delay_us(pulseSure3);  } 
04E8:  BSF    03.5
04E9:  BCF    08.0
04EA:  BCF    03.5
04EB:  BSF    08.0
04EC:  MOVF   37,W
04ED:  MOVWF  60
04EE:  INCF   60,F
04EF:  DECF   60,F
04F0:  BTFSC  03.2
04F1:  GOTO   4F6
04F2:  MOVLW  FF
04F3:  MOVWF  61
04F4:  CALL   031
04F5:  GOTO   4EF
04F6:  MOVF   36,W
04F7:  MOVWF  61
04F8:  CALL   031
04F9:  BSF    03.5
04FA:  BCF    08.0
04FB:  BCF    03.5
04FC:  BCF    08.0
04FD:  MOVF   37,W
04FE:  MOVWF  60
04FF:  INCF   60,F
0500:  DECF   60,F
0501:  BTFSC  03.2
0502:  GOTO   507
0503:  MOVLW  FF
0504:  MOVWF  61
0505:  CALL   031
0506:  GOTO   500
0507:  MOVF   36,W
0508:  MOVWF  61
0509:  CALL   031
050A:  INCF   54,F
050B:  BTFSC  03.2
050C:  INCF   55,F
050D:  GOTO   4DE
....................     
....................    
....................    } 
....................      // X sayac artý deðer ise sola dogru gitsin 
....................      if(abs(xSayac)==xSayac) 
050E:  MOVF   39,W
050F:  MOVWF  7A
0510:  MOVF   38,W
0511:  BTFSS  39.7
0512:  GOTO   51C
0513:  MOVF   38,W
0514:  SUBLW  00
0515:  MOVWF  77
0516:  CLRF   7A
0517:  MOVF   39,W
0518:  BTFSS  03.0
0519:  INCFSZ 39,W
051A:  SUBWF  7A,F
051B:  MOVF   77,W
051C:  MOVWF  60
051D:  MOVF   7A,W
051E:  MOVWF  61
051F:  MOVF   38,W
0520:  SUBWF  60,W
0521:  BTFSS  03.2
0522:  GOTO   563
0523:  MOVF   39,W
0524:  SUBWF  61,W
0525:  BTFSS  03.2
0526:  GOTO   563
....................      { adimSol=xSayac;  
0527:  MOVF   39,W
0528:  MOVWF  3F
0529:  MOVF   38,W
052A:  MOVWF  3E
....................          output_low(stepX_dir); 
052B:  BCF    5D.4
052C:  MOVF   5D,W
052D:  BSF    03.5
052E:  MOVWF  07
052F:  BCF    03.5
0530:  BCF    07.4
....................     for(h=0; h<adimSol; h++) 
0531:  CLRF   59
0532:  CLRF   58
0533:  MOVF   59,W
0534:  SUBWF  3F,W
0535:  BTFSS  03.0
0536:  GOTO   563
0537:  BTFSS  03.2
0538:  GOTO   53D
0539:  MOVF   3E,W
053A:  SUBWF  58,W
053B:  BTFSC  03.0
053C:  GOTO   563
....................     {  output_high(stepX_step); delay_us(pulseSure3); output_low(stepX_step); delay_us(pulseSure3);  } 
053D:  BSF    03.5
053E:  BCF    08.3
053F:  BCF    03.5
0540:  BSF    08.3
0541:  MOVF   37,W
0542:  MOVWF  60
0543:  INCF   60,F
0544:  DECF   60,F
0545:  BTFSC  03.2
0546:  GOTO   54B
0547:  MOVLW  FF
0548:  MOVWF  61
0549:  CALL   031
054A:  GOTO   544
054B:  MOVF   36,W
054C:  MOVWF  61
054D:  CALL   031
054E:  BSF    03.5
054F:  BCF    08.3
0550:  BCF    03.5
0551:  BCF    08.3
0552:  MOVF   37,W
0553:  MOVWF  60
0554:  INCF   60,F
0555:  DECF   60,F
0556:  BTFSC  03.2
0557:  GOTO   55C
0558:  MOVLW  FF
0559:  MOVWF  61
055A:  CALL   031
055B:  GOTO   555
055C:  MOVF   36,W
055D:  MOVWF  61
055E:  CALL   031
055F:  INCF   58,F
0560:  BTFSC  03.2
0561:  INCF   59,F
0562:  GOTO   533
....................      
....................     
....................     } 
....................      // Z sayac artý deger ise asagý insin  
....................      if(abs(zSayac)==zSayac) 
0563:  MOVF   3B,W
0564:  MOVWF  7A
0565:  MOVF   3A,W
0566:  BTFSS  3B.7
0567:  GOTO   571
0568:  MOVF   3A,W
0569:  SUBLW  00
056A:  MOVWF  77
056B:  CLRF   7A
056C:  MOVF   3B,W
056D:  BTFSS  03.0
056E:  INCFSZ 3B,W
056F:  SUBWF  7A,F
0570:  MOVF   77,W
0571:  MOVWF  60
0572:  MOVF   7A,W
0573:  MOVWF  61
0574:  MOVF   3A,W
0575:  SUBWF  60,W
0576:  BTFSS  03.2
0577:  GOTO   5B8
0578:  MOVF   3B,W
0579:  SUBWF  61,W
057A:  BTFSS  03.2
057B:  GOTO   5B8
....................      {  
....................      adimAlt=zSayac; 
057C:  MOVF   3B,W
057D:  MOVWF  43
057E:  MOVF   3A,W
057F:  MOVWF  42
....................          output_low(stepZ_dir); 
0580:  BCF    5D.3
0581:  MOVF   5D,W
0582:  BSF    03.5
0583:  MOVWF  07
0584:  BCF    03.5
0585:  BCF    07.3
....................     for(g=0; g<adimAlt; g++) 
0586:  CLRF   57
0587:  CLRF   56
0588:  MOVF   57,W
0589:  SUBWF  43,W
058A:  BTFSS  03.0
058B:  GOTO   5B8
058C:  BTFSS  03.2
058D:  GOTO   592
058E:  MOVF   42,W
058F:  SUBWF  56,W
0590:  BTFSC  03.0
0591:  GOTO   5B8
....................     {  output_high(stepZ_step); delay_us(pulseSure3); output_low(stepZ_step); delay_us(pulseSure3);  } 
0592:  BSF    03.5
0593:  BCF    08.0
0594:  BCF    03.5
0595:  BSF    08.0
0596:  MOVF   37,W
0597:  MOVWF  60
0598:  INCF   60,F
0599:  DECF   60,F
059A:  BTFSC  03.2
059B:  GOTO   5A0
059C:  MOVLW  FF
059D:  MOVWF  61
059E:  CALL   031
059F:  GOTO   599
05A0:  MOVF   36,W
05A1:  MOVWF  61
05A2:  CALL   031
05A3:  BSF    03.5
05A4:  BCF    08.0
05A5:  BCF    03.5
05A6:  BCF    08.0
05A7:  MOVF   37,W
05A8:  MOVWF  60
05A9:  INCF   60,F
05AA:  DECF   60,F
05AB:  BTFSC  03.2
05AC:  GOTO   5B1
05AD:  MOVLW  FF
05AE:  MOVWF  61
05AF:  CALL   031
05B0:  GOTO   5AA
05B1:  MOVF   36,W
05B2:  MOVWF  61
05B3:  CALL   031
05B4:  INCF   56,F
05B5:  BTFSC  03.2
05B6:  INCF   57,F
05B7:  GOTO   588
....................      
....................     } 
....................      
....................     adimUst=0;  adimAlt=0;  adimSol=0;  adimSag=0; zSayac=0; xSayac=0; sayma=0; 
05B8:  CLRF   41
05B9:  CLRF   40
05BA:  CLRF   43
05BB:  CLRF   42
05BC:  CLRF   3F
05BD:  CLRF   3E
05BE:  CLRF   3D
05BF:  CLRF   3C
05C0:  CLRF   3B
05C1:  CLRF   3A
05C2:  CLRF   39
05C3:  CLRF   38
05C4:  CLRF   5C
....................        
....................     } 
....................    // ----------------------------------------------------------------- 
....................     
....................       // --------------------------- LED YAK ----------------------------- 
....................    if(gelenVeri=='M')  { solust(); } 
05C5:  MOVF   2D,W
05C6:  SUBLW  4D
05C7:  BTFSS  03.2
05C8:  GOTO   5ED
....................    if(gelenVeri=='N')  { ust();    } 
*
05ED:  MOVF   2D,W
05EE:  SUBLW  4E
05EF:  BTFSS  03.2
05F0:  GOTO   615
....................    if(gelenVeri=='S')  { sagust(); } 
*
0615:  MOVF   2D,W
0616:  SUBLW  53
0617:  BTFSS  03.2
0618:  GOTO   63D
....................    if(gelenVeri=='L')  { sol();    } 
*
063D:  MOVF   2D,W
063E:  SUBLW  4C
063F:  BTFSS  03.2
0640:  GOTO   665
....................    if(gelenVeri=='R')  { orta();   } 
*
0665:  MOVF   2D,W
0666:  SUBLW  52
0667:  BTFSS  03.2
0668:  GOTO   68D
....................    if(gelenVeri=='P')  { sag();    } 
*
068D:  MOVF   2D,W
068E:  SUBLW  50
068F:  BTFSS  03.2
0690:  GOTO   6B5
....................    if(gelenVeri=='T')  { solalt(); } 
*
06B5:  MOVF   2D,W
06B6:  SUBLW  54
06B7:  BTFSS  03.2
06B8:  GOTO   6DD
....................    if(gelenVeri=='Y')  { alt();    } 
*
06DD:  MOVF   2D,W
06DE:  SUBLW  59
06DF:  BTFSS  03.2
06E0:  GOTO   705
....................    if(gelenVeri=='Z')  { sagalt(); }   
*
0705:  MOVF   2D,W
0706:  SUBLW  5A
0707:  BTFSS  03.2
0708:  GOTO   72D
....................     
....................    // ----------------------------------------------------------------- 
*
072D:  BCF    0C.5
072E:  BCF    0A.3
072F:  BCF    0A.4
0730:  GOTO   01D
.................... } 
....................  
....................  
.................... void main() 
*
0747:  MOVLW  81
0748:  BSF    03.5
0749:  MOVWF  19
074A:  MOVLW  A6
074B:  MOVWF  18
074C:  MOVLW  90
074D:  BCF    03.5
074E:  MOVWF  18
074F:  CLRF   2F
0750:  MOVLW  1E
0751:  MOVWF  2E
0752:  MOVLW  03
0753:  MOVWF  31
0754:  MOVLW  E8
0755:  MOVWF  30
0756:  CLRF   33
0757:  MOVLW  64
0758:  MOVWF  32
0759:  MOVLW  03
075A:  MOVWF  35
075B:  MOVLW  E8
075C:  MOVWF  34
075D:  MOVLW  01
075E:  MOVWF  37
075F:  MOVLW  90
0760:  MOVWF  36
0761:  CLRF   39
0762:  CLRF   38
0763:  CLRF   3B
0764:  CLRF   3A
0765:  MOVLW  01
0766:  MOVWF  5C
0767:  MOVLW  FF
0768:  MOVWF  5D
0769:  BSF    03.5
076A:  BSF    1F.0
076B:  BSF    1F.1
076C:  BSF    1F.2
076D:  BCF    1F.3
076E:  MOVLW  07
076F:  MOVWF  1C
0770:  BCF    03.7
0771:  MOVLW  1F
0772:  ANDWF  03,F
.................... {  
....................      enable_interrupts(GLOBAL); 
*
0776:  MOVLW  C0
0777:  IORWF  0B,F
....................      output_high(stepX_E); 
0778:  BSF    03.5
0779:  BCF    08.2
077A:  BCF    03.5
077B:  BSF    08.2
....................      output_high(stepZ_E); 
077C:  BSF    03.5
077D:  BCF    08.1
077E:  BCF    03.5
077F:  BSF    08.1
....................      output_high(led1x1); 
0780:  BSF    03.5
0781:  BCF    06.5
0782:  BCF    03.5
0783:  BSF    06.5
....................      output_high(led1x2);  
0784:  BSF    03.5
0785:  BCF    06.4
0786:  BCF    03.5
0787:  BSF    06.4
....................      output_high(led1x3);  
0788:  BSF    03.5
0789:  BCF    06.3
078A:  BCF    03.5
078B:  BSF    06.3
....................      output_high(led2x1);  
078C:  BSF    03.5
078D:  BCF    06.2
078E:  BCF    03.5
078F:  BSF    06.2
....................      output_high(led2x2);  
0790:  BSF    03.5
0791:  BCF    06.1
0792:  BCF    03.5
0793:  BSF    06.1
....................      output_high(led2x3);  
0794:  BSF    03.5
0795:  BCF    06.0
0796:  BCF    03.5
0797:  BSF    06.0
....................      output_high(led3x1);  
0798:  BSF    03.5
0799:  BCF    08.7
079A:  BCF    03.5
079B:  BSF    08.7
....................      output_high(led3x2);  
079C:  BSF    03.5
079D:  BCF    08.6
079E:  BCF    03.5
079F:  BSF    08.6
....................      output_high(led3x3); 
07A0:  BSF    03.5
07A1:  BCF    08.5
07A2:  BCF    03.5
07A3:  BSF    08.5
....................      delay_ms(1000); 
07A4:  MOVLW  04
07A5:  MOVWF  5E
07A6:  MOVLW  FA
07A7:  MOVWF  5F
07A8:  GOTO   731
07A9:  DECFSZ 5E,F
07AA:  GOTO   7A6
....................      output_low(led1x1); 
07AB:  BSF    03.5
07AC:  BCF    06.5
07AD:  BCF    03.5
07AE:  BCF    06.5
....................      output_low(led1x2);  
07AF:  BSF    03.5
07B0:  BCF    06.4
07B1:  BCF    03.5
07B2:  BCF    06.4
....................      output_low(led1x3);  
07B3:  BSF    03.5
07B4:  BCF    06.3
07B5:  BCF    03.5
07B6:  BCF    06.3
....................      output_low(led2x1);  
07B7:  BSF    03.5
07B8:  BCF    06.2
07B9:  BCF    03.5
07BA:  BCF    06.2
....................      output_low(led2x2);  
07BB:  BSF    03.5
07BC:  BCF    06.1
07BD:  BCF    03.5
07BE:  BCF    06.1
....................      output_low(led2x3);  
07BF:  BSF    03.5
07C0:  BCF    06.0
07C1:  BCF    03.5
07C2:  BCF    06.0
....................      output_low(led3x1);  
07C3:  BSF    03.5
07C4:  BCF    08.7
07C5:  BCF    03.5
07C6:  BCF    08.7
....................      output_low(led3x2);  
07C7:  BSF    03.5
07C8:  BCF    08.6
07C9:  BCF    03.5
07CA:  BCF    08.6
....................      output_low(led3x3); 
07CB:  BSF    03.5
07CC:  BCF    08.5
07CD:  BCF    03.5
07CE:  BCF    08.5
....................     
....................    while(TRUE) 
....................    { 
....................        
....................       enable_interrupts(int_rda); 
07CF:  BSF    03.5
07D0:  BSF    0C.5
....................       output_low(stepX_E); 
07D1:  BCF    08.2
07D2:  BCF    03.5
07D3:  BCF    08.2
....................       output_low(stepZ_E); 
07D4:  BSF    03.5
07D5:  BCF    08.1
07D6:  BCF    03.5
07D7:  BCF    08.1
07D8:  GOTO   7CF
....................        
....................    }   
.................... } 
....................  
07D9:  SLEEP
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
